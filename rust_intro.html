
	<!DOCTYPE html><html><head>
	<title>Rust Intro</title>
	<style type="text/css"> 
	body { font-family:'Helvetica', Arial, sans-serif; font-size:15px; 
			color: #333; background-color:#FFF; line-height:1.5em; width:960px;
      padding:0px}
	h1 { font-size: 3.5em; line-height: 1em; color:#000; background-color:#FFF; 
      text-align:center}
  h1.chapter { background-color: #333; color: #fff; line-height:2em }
	h2 { font-size: 2em; line-height: 1em; color:#000 }
	h3 { font-size:1.5em; line-height: 1em; color:#000 } 
  h4 { font-size:1em; line-height: 0em; padding-top:1em }
	code { 	font-family: 'Monaco', monospace; font-size:12px; background:#EEE}
	pre { color:#000; background:#EEE; padding:1em; line-height:1.35em }
	#content { margin: 3.5em }
	table { border-collapse: collapse; border: 1px solid #333 }
	td { border: 1px solid #555; padding-left: 1em } 
	th { color: #fff; background-color: #333 }
	</style></head>
	<body><div id="content">
<h1>Rust</h1>

<h3>Variables</h3>

<p>Are declared using let</p>

<pre><code>let a = 10;
</code></pre>

<p>Most types can be inferred, but if you need a specific type:</p>

<pre><code>let b: i64 = 2000000000000;
</code></pre>

<p>All variables are immutable by default, to allow mutation:</p>

<pre><code>let mut c = 30;
</code></pre>

<p>Any unused variables get a warning by default, to suppress that:</p>

<pre><code>let mut _d = 40;
</code></pre>

<p>variables and functions are in <code>snake_case</code></p>

<pre><code>let my_favorite_number = 7i;
</code></pre>

<p>Whereas types are in CamelCase</p>

<pre><code>type MyInt = int;
</code></pre>

<p>All statements are expressions, this is what the semicolons do they denote the end of an expression</p>

<pre><code>let item = &quot;ice cream&quot;;
let price: f64 =
if item == &quot;salad&quot; {
  3.50
} else if item == &quot;muffin&quot; {
  2.50
} else if item == &quot;ice cream&quot; {
  101.20
} else {
  1.00
};
</code></pre>

<p>The lack of a semicolon at the end of the line gives the entire block the value of that expression, so the lack of semicolons at the end of these mean that, once evaluated, the block will return the value of the conditional that evaluated to true</p>

<h3>Various Variable Types</h3>

<pre><code>let e: int = 1;     // int
let f = 10i;        // int
let g = 100u;       // unsigned int
let h = 15i8;       // 8 bit int
let i = 1000i32;    // 32 bit int
let j = 1000i64;    // 64 bit int
let k = 1e6f32;     // 32 bit float
let l = 2.1e-10f64; // 64 bit float
</code></pre>

<p>true and false are literals of type bool</p>

<pre><code>let tr = true;
let fa = false;
</code></pre>

<p>Strings are complicated, but here are some basics: Chars are four byte Unicode characters with single quotes</p>

<pre><code>let m = &#39;a&#39;;
</code></pre>

<p>Double-quoted strings will recognize some escape sequences:</p>

<pre><code>let n = &quot;Hello, world!\n&quot;;
</code></pre>

<p>Raw string literals process none of these and use #hashes# at the beginning and end to define them</p>

<pre><code>let o = r##&quot;Hello, world!\n&quot;##;
</code></pre>

<p>The unit type, written as () has a single value of ()</p>

<pre><code>let p = ();
</code></pre>

<h3>Blocks</h3>

<p>Are denoted by curly braces and are the standard unit of code execution. Unlike in other C-like languages the curly braces are never optional, but it seems idiomatically fine to have them on the same line, so there is no need for the Javalike extension of simple statements across 5-6 lines:</p>

<pre><code>let s = if true { 3 } else { 4 };
</code></pre>

<h3>Expressions</h3>

<p>This is probably wrong on some fronts, but basically everything is an expression, or can be one. The semicolon denotes the end of an expression. Understanding this helps to understand when to use semicolons and when not to use them. Within a block, if you don&#39;t terminate the expression with a semicolon then the value of the expression gets passed to the block.</p>

<pre><code>fn is_four(x: int) -&gt; bool {
  x == 4
}

fn signum(x: int) -&gt; int {
  if x &lt; 0 { -1 }
  else if x &gt; 0 { 1 }
  else { 0 }
}
</code></pre>

<p>As seen above, none of the expressions within the block use a semicolon at the end and thus the values, in this case a bool and some primitives, are inherited by the block and implicitly returned as the value of the function.</p>

<h3>Operators</h3>

<p>Operators are all pretty standard:
- Arithmetic: <code>+ - * /</code>
- <code>!</code> applied to an integer flips all the bits
- Bitwise: <code>&lt;&lt; &gt;&gt; &amp; | ^</code>
- Comparison: <code>== != &lt; &gt; &lt;= &gt;=</code>
- Boolean: <code>&amp;&amp; ||</code> and they short circuit</p>

<h3>Compile time casting</h3>

<p>Using the <code>as</code> command to cast between different primitive values</p>

<pre><code>println!(&quot;{:0.2f}&quot;, (f as f32));
let q: f64 = 4.0;
let r: uint = q as uint;
</code></pre>

<h3>Syntax Extensions</h3>

<p>Are special forms provided by the libraries rather than
being built into the language, all language extensions have names
that end with !</p>

<h3>Conditionals</h3>

<pre><code>let s = if true { 3 } else { 4 };
</code></pre>

<p>The condition must be of type bool, no implicit conversion happens, so there is no inherent &quot;truthiness&quot; of certain values:</p>

<pre><code>let t = if 4 { 4 } else { 3 }; &lt;- Doesn&#39;t work
</code></pre>

<p>If the blocks have a value (no semicolon at the end, thus passing the value to the block), then every arm of the conditional must return the same type.</p>

<h3>Pattern Matching</h3>

<p>Is a generalized and more powerful version of the switch statement the first pattern that matches executes, there is no need to break <code>_</code> is a wildcard that acts as an else statement, it matches anything and must always be put last because any pattern beneath it will never be reached. Furthermore, _ must be included to ensure that something gets matched</p>

<pre><code>let t = 12i;
match t {
  0       =&gt; println!(&quot;zero!&quot;),
          1 | 2   =&gt; println!(&quot;one or two&quot;),
          3..10   =&gt; println!(&quot;three to ten&quot;),
          10..20  =&gt; println!(&quot;ten to twenty&quot;),
          _       =&gt; println!(&quot;something else entirely&quot;)
}
</code></pre>

<p>Each pattern must be followed by a comma </p>

</div></body></html>